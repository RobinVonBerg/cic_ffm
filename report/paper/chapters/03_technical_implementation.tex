\chapter{Technische Realisation}

\section{Aufgabenbereiche}

    Die technischen Aspekte des Gerippten lassen sich grob in folgende Teilbereiche aufgliedern:

    \begin{itemize}
        \item Beleuchtung der Tonnenaußenwand inklusive Animation der Lichteffekte sowie Beleuchtung des Flaschenrings
        \item Sensorik zur Detektion von Flaschen im Flaschenring
        \item Detektion von Gegenständen die in den Behälter geworfen werden
        \item Messung des Füllstandes
        \item Verkablung der Sensorik und der LEDs.
        \item Austausch von Informationen zwischen mehreren Endgeräten
        \item Verarbeitung der Sensordaten und Ansteuerung der Beleuchtung
    \end{itemize}

    In den nachfolgenden Kapiteln werden die zur Realisierung der verschiedenen Teilaspekte genutzten Komponenten beschrieben und diskutiert.


\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\section{Mikrocontroller}

    \subsection{Diskussion}
        Als zentrale Steuerungskomponente ist die Wahl des Mikrocontrollers von zentraler Bedeutung für die technische Realisierung des Projekts. Die wichtigste Eigenschaft des Mikrocontrollers ist in diesem Projekt die generelle Verbreitung des Mikrocontrollers, da die Einarbeitungszeit sehr kurz ist und somit eine große Auswahl von Informationsquellen entscheidende Vorteile bringt. Dadurch stechen zwei Hersteller besonders heraus. Zum einen Arduino, die eine große Auswahl unterschiedlichster Mikrocontroller mit verschiedenstem Funktionsumfang anbieten und zum anderen Espressif, deren ESP32 Mikrocontroller eher als "Alleskönner" bezeichnet werden kann, da er im Vergleich zu den meisten Arduino Modellen wesentlich mehr und bessere Hardware bietet.
        Eine weitere Möglichkeit bietet die Nutzung des Einplatinencomputers Raspberry Pi, der einen weitaus größeren Funktionsumfang und wesentlich mehr Rechenleistung besitzt als ein Mikrocontroller. Die Nachteile des Raspberry Pi liegen in den hohen Anschaffungskosten und dem ebenfalls hohen Stromverbrauch. Im allgemeinen ist ein Raspberry Pi für dieses Projekt überdimensioniert, da ein Großteil des Mehrwertes den dieser gegenüber einem Mikrocontroller bietet in diesem Projekt keine Verwendung fände.\\
        
        Da eine kabellose Kommunikation der Mikrocontroller untereinander realisiert werden soll, ist es essenziell, dass der Mikrocontroller mit einem WiFi oder Bluetooth Modul ausgestattet ist. Der ESP32 bringt beides mit. Arduino bietet ebenfalls einige Modelle an, die mit mindestens einem der Module ausgestattet sind. Insbesondere die Nano 33 Reihe von Arduino bietet Geräte, die für die Verwendung in diesem Projekt die notwendigen Kriterien erfüllen. Hier sind speziell die Modelle Nano 33 BLE und Nano 33 IoT hervorzuheben. Das Modell Nano 33 IoT ist dabei speziell für die Verwendung in Internet of Things Geräten designed und bietet sowohl ein WiFi als auch ein Bluetooth Modul. Das Modell Nano 33 BLE besitzt lediglich ein Bluetooth Modul, dieses ist jedoch mit Bluetooth 5 etwas moderner als die Bluetooth 4.2 Variante, die im Nano 33 IoT Modell verbaut ist. Zudem besitzt das BLE Modell einen leistungsstärkeren Prozessor, der jedoch durch integrierte Energiesparfunktionen mindestens genauso energiesparend ist. Der Energieverbrauch stellt sich für dieses Projekt ebenfalls als wichtiger Faktor heraus, da für eine mögliche Weiterführung des Projekts eine Stromversorgung der Geräte über Solarzellen und Akkus implementierbar sein soll. Die hier diskutierten Vor- und Nachteile der 3 zur Verfügung stehenden Mikrocontrollern wird in Tabelle \ref{tab:compare_mics} nochmals in kürze zusammengefasst.

        \begin{table}[H]
            \caption{Vergleich der Mikrocontroller ESP32, Nano 33 IoT und Nano 33 BLE}
            \centering
            \begin{tabularx}{\textwidth}{  X | X | X  }
                \textbf{Espressif ESP32} & \textbf{Arduino Nano 33 IoT} & \textbf{Arduino Nano 33 BLE}\\ [0.5ex] \hline\hline
                Leistungsstärkster Mikrocontroller &
                Am wenigsten Leistung im Vergleich &
                Leistungsstarker Prozessor\\
                &&\\
                Bluetooth \& WiFi &
                Bluetooth \& WiFi &
                Nur Bluetooth, dafür Bluetooth 5 \\
                &&\\
                Vergleichsweise hoher Stromverbrauch &
                Geringer Stromverbrauch &
                Geringer Stromverbrauch \\
            \end{tabularx}
            \label{tab:compare_mics}
        \end{table}

        Im Kapitel \ref{sec:communications} wird erläutert, dass die Kommunikation über den Bluetooth beziehungsweise Bluetooth Low Energy Standard erfolgen soll. Somit bieten die WiFi Module, die der ESP32 und der Nano 33 IoT Mikrocontroller mitbringen keine weiteren Vorteile gegenüber dem Nano 33 BLE Mikrocontroller. Da dieser außerdem einen sehr geringen Stromverbrauch im Verhältnis zu seiner Leistungsfähigkeit aufweist, wurde dieser für die Verwendung in diesem Projekt ausgewählt.


    \subsection{Platform \& Code-Struktur}\label{sec:platform}

        Als Programmiersprache kommt das systemnahe C++ zum Einsatz, die klassische Wahl zur Programmierung von Arduinos.
        Allerdings haben wir uns schon zu Beginn von der ArduinoIDE getrennt, da uns dort ein paar Quality of Life Features nicht zu Verfügung standen.
        Als Alternative haben wir uns für das PlatformIO Plugin für Visual Studio Code entschieden. Unter den benötigten Features fällt die Möglichkeit Environments zu definieren und damit die Möglichkeit mehrere Main-Files für verschiedene Arduinos in der selben Codebasis zu halten. Je nach ausgewähltem Environment wird dann ein spezifizierte Main verwendet indem alle anderen exkludiert werden. Auch konnten wir Makros an den Compiler übergeben um Arduinos IDs zuzuweisen, die verwendet werden um unterschiedliche/einzigartige UUIDs zu verwenden. Im Codeausschnitt\,\ref{lst:platformio_1} ist beispielhaft das Environment \enquote{transmitter} zu finden, welches das Makro ARDUINO\_ID=3 definiert und die Dateien main\_receiver.cpp, main\_dtof.cpp und main\_rest.cpp beim kompilieren rausfiltert.
        Zusätzlich bietet PlatformIO eine Definition von Abhängigkeiten auf Projektebene, so hatten wir immer die selben Versionen der Bibliotheken und zusätzlich werden diese Abhängigkeiten sowie die benötigte Software zum Arbeiten mit Nano 33 BLE Arduinos automatisch heruntergeladen.

        \begin{listing}
            \begin{minted}{ini}
[env]
build_flags = -Wall
lib_ldf_mode = deep+
platform = nordicnrf52
board = nano33ble
framework = arduino
monitor_speed = 115200
build_src_filter = +<*> -<.git/>
lib_deps = 
	adafruit/Adafruit NeoPixel@^1.10.4
	sparkfun/SparkFun Qwiic TMF882X Library@^1.0.0
	arduino-libraries/ArduinoBLE@^1.2.2
	thijse/ArduinoLog@^1.1.1

[env:transmitter]
build_flags = 
    ${env.build_flags}
    -DARDUINO_ID=3
build_src_filter =
    ${env.build_src_filter}
    -<main_receiver.cpp>
    -<main_dtof.cpp>
    -<main_test.cpp>
upload_port = /dev/ttyACM0
monitor_port = /dev/ttyACM0

...
            \end{minted}
            \caption{Auszug aus der platformio.ini Datei}
            \label{lst:platformio_1}
        \end{listing}

        Die Strukturierung des Codes ist aufgeteilt in jeweils hpp- und cpp-Datei für jede Komponente unseres Modell. So führen wir eine weitere Abstrahierungsebene ein und können unsere Main-Dateien übersichtlicher und vorallem kompakter gestalten, in dem die dort verwendeten Funktionen auf unsere Aufgaben angepasst sind.
        Dabei ist die grundlegende Struktur einer Klasse, oft aufgeteilt in einen Konstruktor zum Setzen der benötigten Instanzvariablen, einer init()-Methode die im Setup aufgerufen wird, mehr oder wenig abstrahierte  Methoden, wie beispielsweise BLEPeripheralWrapper::publishEvent(u\_int8\_t val) die den Wert einer BLE-Characteristic aktualisiert und nach einem gewissen Intervall wieder zurücksetzt oder u\_int8\_t LevelMeter::getFillLevel(), die den aktuellen Füllstand zurückgibt, sowie in manchen Fällen update()-Methoden.
        In diesen wurden alle Aufrufe vereint die periodisch erfolgen müssen.


\section{Beleuchtung}

    \subsection{Diskussion}

        Um die Flaschen des Flaschenrings und die Rauten zu beleuchten benötigen wir LEDs. Es eröffnet sich herbei ein großer Raum von Optionen. LEDs sind zu unterscheiden in Größe und Form, in Helligkeit und der Art der Ansteuerung und zwischen RGB- und RGBW-LEDS.
        Eine der Kategorien konnten wir mit dem Rat von Prof. Hoffmann und Simon zu Beginn klären. Um die Menge der benötigten LEDs individuell über ein Arduino ansteuern zu können, benötigen wir LEDs mit einem integriertem Driver-Chip. NeoPixel von Adafruit, oder die vielen äquivalente Optionen auf dem Markt ermöglichen diese Funktionalität in dem sie als 24 oder 32 Bit Shift-Register agieren. Dabei wird die Farbintensität jeder der drei oder vier Farben (RGB oder RGBW) als ein 8-Bit Wert angegeben und von LED zu LED weitergeleitet.
        Wird ein RESET-Signal gesendet, wird der zuletzt gespeicherte Wert angezeigt.

        Weitere Überlegungen mussten wir uns besonders hinsichtlich der Größe und Form machen. Für die Animationen der Tonne wollten wir jede Raute an den oberen Kanten, dessen Längen jeweils ca. 10cm betragen, mit LEDs bestücken. Hierfür haben sich LED-Strips angeboten, wobei wir möglichst schmale benötigen, damit sie, wenn eine Person den Mülleimer von oben anguckt, in der Rautenstruktur verschwinden. Als alternativen Ansatz hatten wir vorher überlegt die Rauten mit einzelnen LEDs zu beleuchten, doch durch den enormen Aufwand der Verkabelung haben wir diesen Ansatz im Laufe der Entwurfsphase wieder verworfen.

        Für die LEDs des Flaschenrings wiederum haben wir vorallem eine weitere Anforderung: Die Helligkeit. Dadurch dass das Licht durch die Flaschen gefiltert wird, müssen wir sichergehen, dass die Lichtintensität hoch genug ist. Bei der Recherche haben wir zwei Optionen gefunden.
        Einerseits ebenfalls die NeoPixel, hier als einzelne LEDS im RGBW Format um eine höhere Helligkeit zu erzielen, andererseits der \enquote{große Bruder}, die Adafruit NeoPixel Pixies. Diese LEDs laufen statt mit 0.2 Watt mit 3 Watt, ein extremer Unterschied, aber dadurch, dass wir 15 Flaschenringfächer haben, mussten wir uns aus Budgetgründen für jeweils zwei LEDs der kleineren Variante entschieden, die mit den Breakoutboards bei 75ct/Stück liegen während sich die Pixies bei 14.95€/Stück außerhalb jedes Rahmens befinden. Ein weiterer wichtiger Faktor den man hätte beleuchten müssen ist die Hitzeentwicklung der großen LEDs, doch so mussten wir nicht in die Details eintauschen.


    \subsection{Implementation}

        \subsubsection{Hardware}

            \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=10cm]{media/03_technical_implementation/picture_led_strip.jpg}
                \end{center}
                \caption{Eins der drei Segmente des Rauten LED-Strips.}
                \label{fig:picture_led_strip}
            \end{figure}

            Wir haben uns bei der Rautenbeleuchtung für 7 Meter Adafruit Mini Skinny NeoPixel Strips entschieden die mit 30 RGB LEDs pro Meter bestückt sind. So konnten wir den Strip in jeweils 20cm Segmenten unterteilen und jede Raute mit insgesamt 6 LEDs beleuchten.
            Der Strip ist mit 1 Ampere Verbrauch pro Meter angegeben, was die Wahl des 10 Ampere Netzteils begründet.
            Die Strip-Segmenten haben wir dann wieder verbunden, in dem wir die drei Kontakte per Kabel an das nächste Segmenten weitergeleitet haben. (Siehe Abbildung\,\ref{fig:picture_led_strip}) Die Abstände zwischen den Strips und damit die Kabellängen sind abhängig von der Position am Modell.
            Diese Aufteilung wird in Abbildung\,\ref{fig:led_wiring_rhombus} skizziert.

            \begin{figure}[H]
                \begin{center}
                    \includegraphics[width=10cm]{media/03_technical_implementation/leds_3.png}
                \end{center}
                \caption{Anordnung der LED-Strips in der Raute am Modell}
                \label{fig:led_wiring_rhombus}
            \end{figure}
            
            Dort zu erkennen ist, dass wir nur ein Teil der Rauten beleuchtet haben, da es uns an LED-Strips fehlte. Eine aus Rauten bestehende große Raute, die wir aus drei Kabel-Strip-Strängen zusammensetzen.
            So laufen am Ende drei Stecker zum Arduino.\\

            \begin{figure}[H]
                \begin{subfigure}[b]{0.5\textwidth}
                    \centering\includegraphics[width=\textwidth]{media/03_technical_implementation/leds_2.png}
                    \caption{Pin-Belegung auf den verwendeten 6-Pin BreakOut-Boards. Gezogene Lötbrücken sind in grau eingezeichnet.}
                    \label{fig:pins_neopixel}
                \end{subfigure}\quad
                \begin{subfigure}[b]{0.5\textwidth}
                    \centering\includegraphics[width=0.7\textwidth]{media/03_technical_implementation/picture_neopixel.jpg}
                    \caption{Ein Pixel.}
                    \label{fig:picture_neopixel}
                \end{subfigure}
                \caption{NeoPixel RGBW LED SK6812RGBW}
            \end{figure}

            Für die Flaschenring LEDs haben wir Breakoutboards beschafft, auf die wir die LEDs gelötet haben. Diese Boards haben 6 Pins, während die LEDs 4 Pins haben. In der Skizze\,\ref{fig:pins_neopixel} haben wir gezeigt wie wir diese zwei Extra-Pins dafür verwenden, über Lötbrücken Strom und Ground im Kabelbaum an die nächsten LEDs weiterzuleiten. Diese zwei Kabelbäume hat vorallem Moritz aus der HCU gebaut, wohlmöglich eine der aufwendigsten Unterfange unseres Projekts. Den Aufbau eine solchen Kabelbaums ist in Abbildung\,\ref{fig:led_wiring_1} gezeigt, der fertige Kabelbaum in Abbildung\,\ref{fig:picture_bottle_leds}.

            \begin{figure}[H]
                \begin{subfigure}[b]{0.5\textwidth}
                    \centering\includegraphics[width=8cm]{media/03_technical_implementation/leds_1.png}
                    \caption{Skizze des Aufbaus.}
                    \label{fig:led_wiring_1}
                \end{subfigure}\quad
                \begin{subfigure}[b]{0.5\textwidth}
                    \centering\includegraphics[width=6cm]{media/03_technical_implementation/picture_bottle_leds.jpg}
                    \caption{Fertiggestellter Kabelbaum in Betrieb.}
                    \label{fig:picture_bottle_leds}
                \end{subfigure}
                \caption{Kabelbäume der Flaschenring LEDs}
            \end{figure}

            
        \subsubsection{Software}

            Softwareseitig bieten die Neopixel eine sehr gute Integration im Arduino Universum mit der Bibliothek \href{https://github.com/adafruit/Adafruit_NeoPixel}{\enquote{Adafruit\_NeoPixel}}.
            Jeder LED-Strang benötigt nur ein Digital-Pin als Datenleitung.
            In der Initialisierung werden Pin-Nummer, Anzahl der hintereinander geschalteten LEDs und der Anordnung der Farbwerte in den Chips benötigt. Für die LEDs des Flaschenrings ist das GRBW für die LED-Strips GRB.
            Ab diesem Zeitpunkt stehen zwei essentielle Methoden zur Verfügung.
            Mit der Klassenmethode 

            \begin{minted}{cpp}
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c)
            \end{minted}

            kann einer LED über einen Index eine Farbe zugewiesen werden.
            Diese Farbe ist eine Konkatenation der 4 8-Bit Werten (Siehe Codeausschnitt\,\ref{lst:led_concatenation}).
            Wird kein Weiß verwendet, wird dieser Wert beim Weiterleiten an die LEDs verworfen.

            \begin{listing}
                \begin{minted}{cpp}
static uint32_t Color(uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
    return ((uint32_t)w << 24) | ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;
}
                \end{minted}
                \caption{Konkatenation der 4 8-Bit Werte der Farben RGBW. - Adafruit\_NeoPixel}
                \label{lst:led_concatenation}
            \end{listing}

            Die zweite Klassenmethode

            \begin{minted}{cpp}
void Adafruit_NeoPixel::show(void)
            \end{minted}

            lässt alle LEDs ihren letzten gesetzten Farbwert anzeigen.\\

            Während die Realisation der Animation der Rauten im nächsten Kapitel behandelt wird, bedienen sich die Flaschenring-LEDs direkt den Funktionen oben erwähnten Funktionen, sodass die LEDs in jedem Schleifendurchlauf des Arduinos ihren Farbwert zugewiesen bekommen und dieser angezeigt wird.
            Das Neusetzen der Farbwerte muss regelmäßig in einem Interval geringer einer Sekunde erfolgen, da sonst unregelmäßige Abweichungen auftreten.


\section{Animation}

    \subsection{Diskussion}

        Grundlegend sind Animationen Farbwerte über Zeit. Da wir jede LED einzeln ansprechen können, haben wir die größtmögliche Freiheiten in der Gestaltung.
        Es stellten sich nun mehrere Fragen. In welchem Format benötigen wir die Farbwerte? Wollen wir einen Wert für jede LED speichern, oder führen wir eine Abstraktionsebene ein. Wie lange sollen die Animationen spielen und in welcher Framerate?

        Zwei Fragen ließen sich durchs Ausprobieren klären.
        Animationen konnten wir mit einer Dauer von 2 Sekunden so darstellen, dass sie möglichst schnell, aber in einer organischen Bewegung umsetzbar waren und als Framerate hatten wir ab 10 Frames pro Sekunde ein flüssiges Ergebnis.

        Des weiteren haben wir uns als Team auf eindimensionale Animationen verständigt die nur in der Vertikalen variieren, sodass wir, wie in Abbildung\,\ref{fig:led_wiring_rhombus} gezeigt, 21 (7 * 3) unterschiedliche Höhenwerte pro Frame benötigen.

        Zusätzlich mussten noch zwei technische Aspekte bedacht werden.
        Animationen sollten zeitbasiert sein und nicht abhängig davon, dass das Aufrufen der Methoden in einem gleichmäßigem Rhythmus geschehen ablaufen.

    \subsection{Implementation}

        Um möglichst wenige Berechnung während der Laufzeit ausführen zu müssen, haben wir die Farbwerte von vornherein berechnet und in die konkatenierte 32-Bit Form transformiert. 
        So benötigen wir für eine Sekunde 10 Frames mit jeweils 21 32 Bit Werten.
        Ziehen wir in Betracht, dass der Arduino Nano 33 BLE 256KB RAM besitzt wären das 38 Sekunden Animationen die wir im Speicher halten könnten, ausgenommen die RAM-Nutzung der anderen Komponenten.
        Auch wenn wir damit für unseren geplanten Umfang an Animationen auskommen würden, haben wir uns dazu entschieden um weitere Erweiterungen umsetzen zu können, die Animationsdaten in den Flash-Speicher des Chips zu schreiben. Dieser beträgt beim Arduino Nano 33 BLE 1MB.
        Konstante Daten mit dem Schlüsselwort PROGMEM in der Deklaration werden beim Flash-Prozess in den Flash-Speicher geschrieben.
        Um Daten aus dem Flash-Speicher zu lesen gibt es eine Reihe von Methoden die als Parameter den Pointer nehmen und unterschiedliche Byte-Größen lesen. Beispiele sind pgm\_read\_float() und pgm\_read\_word(). Alle diese Funktionalitäten werden von der Bibliothek \enquote{<avr/pgmspace.h>} bereitgestellt.\\
        Bei Animationen mit linearen Farbverläufen, wie wir sie verwenden, muss man zusätzlich beachten, dass ein linearer Verlauf zwischen 0 und 255 vom Menschen nicht als linear wahrgenommen wird. Hierfür gibt es die sogenannte Gamma-Korrektion, eine nichtlineare Funktion die als Array mit 256 Werten implementiert ist. Diese bildet jeden Wert auf einen korrigierten ab, sodass das Endprodukt wieder linear wahrgenommen wird.
        Diese Korrektion wenden wir aber ebenfalls schon beim Erstellen der Animationen an.


    \vspace{1em}
    \framebox[\textwidth]{
        \begin{minipage}{\textwidth-1em}
            \vspace{.4em}
            \textbf{Skript generate\_animation.py}
            \\[1em]            
            Das Generieren der Animationen haben wir in einem Python-Skript modelliert, welches eine Animation mit einer beliebigen Farbe in dem für das Arduino-Programm benötigte Format ausgibt. Es lässt ein Lichtimpuls von unten nach oben wandern und passt die anliegenden Werte sowie den Start und das Ende so an, dass es keine ruckartigen Bewegungen gibt.\\
            Es ist dabei modular aufgebaut, sodass weitere Animationen hinzugefügt werden können.
            \vspace{.4em}
        \end{minipage}
    }
    \vspace{1em}

    Ein Ausschnitt der fertigen Animation ist im Codebeispiel\,\ref{lst:animation_1} zu sehen. \\

    Während wir bei den Farbwerten der Animationen mit 21 Werten arbeiten, müssen wir die 96 LEDs ebenfalls den 21 Höhen zuweisen.
    Das haben wir mit einer einfachen Heightmap realisiert, ein Array das für jeden Index und damit jede LED ein Höhenwert mitbekommt.
    So kann später eine effiziente Berechnung des benötigten Farbwerts erfolgen.\\


    \begin{listing}
        \begin{minted}{cpp}
[...]
static PROGMEM uint32_t ANIMATIONS[AMOUNT_ANIMATIONS][AMOUNT_LED_LEVELS * FRAME_AMOUNT] = 
{
    {
    512, 512, 512, 512, [...]
    1792, 1792, 1792, 1792, [...]
    18688, 29952, 44544, 62720, [...]
    [...]
    }
}
[...]
        \end{minted}
        \caption{Angepasster Auszug aus der animation.hpp}
        \label{lst:animation_1}
    \end{listing}

    Beim Start einer Animation wird nun ein Zeitstempel mithilfe der Methode millis() gespeichert. Jeder Aufruf der im Codeausschnitt\,\ref{lst:animation_2} skizzierten update()-Methode berechnet sich anhand dieses Wertes das Zeit-Delta seit Beginn der Animation, um den aktuellen Frame zu berechnen. Das Array mit den Farbwerten im Flashspeicher besitzt für jede Animation 21 * \enquote{Anzahl Frames} Farbwerte, wobei die ersten 21 Werte dem Frame 0, die nächsten 21 Werte dem Frame 1 zugewiesen sind etc.
    So berechnet sich die aktuelle Position der Animation wie in Zeile 6 zu sehen mit der Addition mit 21 * \enquote{Aktueller Frame}.
    Ausgehend von diesem Pointer wird nun über jede LED iteriert, wobei die Position aus der Height-Map gelesen wird und diese auf den Pointer addiert wird, um den korrekten Farbwert aus dem Flashspeicher zu lesen.
    Bevor diese Berechnung stattfindet wird, wie in Codebeispiel\,\ref{lst:animation_3}, überprüft, ob die aktuelle Animation vollendet ist.

    \begin{listing}
        \begin{minted}{cpp}
// Einschub aus neo_animation.hpp:
const u_int8_t *height_map;

[...]
u_int8_t idx = (millis() - animation_data.ts_start) / 100;
u_int32_t* ptr = animation_data.animation_ptr + (AMOUNT_LED_LAYERS * idx);
for (uint16_t i = 0; i < num_pixels; i++)
{
    pxl.setPixelColor(i, pgm_read_dword(ptr + height_map[i]));
}
pxl.show();
[...]

        \end{minted}
        \caption{Farbwerte zeitbasiert aus dem Flashspeicher lesen - Auszug aus der update()-Methode der neo\_animation.cpp}
        \label{lst:animation_2}
    \end{listing}

    \begin{listing}
        \begin{minted}{cpp}
[...]
if (millis() > (animation_data.ts_start + animation_data.duration)) 
{
    animation_data.state = OFF;
    pxl.clear();
    pxl.show();
} 
[...]
        \end{minted}
        \caption{Animation zeitbasiert beenden. - Auszug aus der update()-Methode der neo\_animation.cpp}
        \label{lst:animation_3}
    \end{listing}


\section{Einwurferkennung}
    \subsection{Diskussion}
        Ein wichtiger Punkt bei der Realisierung der Einwurfserkennung ist, dass nur Gegenstände erkannt werden sollen, die gänzlich in den Behälter geworfen wurden und nicht wieder herausgezogen werden, wie es beispielsweise beim Hereinhalten einer Hand in den Behälter der Fall ist. Um dies zu implementieren muss der Gegenstand auf mindestens zwei übereinanderliegenden Ebenen detektiert werden. Wird auf der oberen Ebene der Gegenstand erkannt, wird ein möglicher Einwurf detektiert. Jedoch erst wenn die obere ebene keinen Gegenstand mehr detektiert, während die untere Ebene diesen weiterhin detektiert ist der Einwurf des Gegenstandes abgeschlossen. Sollte der Gegenstand hingegen zuletzt lediglich auf der oberen Ebene detektiert werden, so wurde er wieder aus dem Behälter herausgezogen und somit wird dies nicht als Einwurf gewertet.\\

        Die Realisierung der zwei Detektionsebenen durch zwei einzelne Sensoren oder Lichtschranken hat jedoch das Problem zur Folge, dass die beiden Sensoren miteinander interferieren, wenn sie die gleiche Lichtwellenfrequenz nutzen, was zur Folge hat, dass eine genaue Abgrenzung zwischen den Ebenen nicht möglich ist. Zur Realisierung dieser Funktion ist es deshalb notwendig Sensoren zu verwenden, die unterschiedliche Lichtwellenfrequenzen verwenden, oder es muss ein Sensor verwendet werden, der die Möglichkeit bietet Objekte in einem dreidimensionalen Bereich zu detektieren, statt nur auf einer bestimmten Ebene zu messen.\\

        Bei der Recherche nach zur Verfügung stehenden Komponenten fiel die Wahl letztlich auf den Mini dToF Imager TMF8821 von SparkFun. Dabei handelt es sich um einen so genannten direct Time of Flight Sensor. Damit ist ein Sensor gemeint, welcher viele kurze Lichtimpulse aussendet und die reflektierten Lichtimpulse wieder detektiert. Um die Entfernung zum Objekt zu bestimmen, welches den Lichtimpuls reflektiert hat, wird die Zeit gemessen, die zwischen der Aussendung des Lichtimpulses und der Detektion des reflektierten Lichtimpulses verstreicht. Eine Besonderheit des TMF8821 ist, dass dieser einen in mehrere Felder aufgeteilten Messbereich besitzt. So kann die Entfernung zu einem Gegenstand beispielsweise in 9 verschiedenen Messbereichen, aufgeteilt auf ein 3x3 Quadrat, gemessen werden. Der Messbereich kann softwareseitig angepasst werden und somit sind verschiedene Messwinkel und Submessbereiche in den Ausprägungen 3x3, 4x4 und 3x6 möglich. Das bedeutet, dass der Messbereich des Sensors bereits in mehrere Ebenen aufgeteilt ist, die getrennt voneinander betrachtet werden können. Technisch realisiert wird dies durch Single Photon Avalanche Photodioden (SPAD), welche hinter einer speziellen Linse angebracht sind, die den Messbereich auf die Fotodioden fokussiert. Die einzelnen Photodioden werden dann den verschiedenen Messzellen zugeordnet und somit kann ein Photon, dass von einer bestimmten SPAD empfangen wird einem Bereich im Feld der Messung zugeordnet werden. Der im folgenden verwendete Begriff 'SPAD Map' bezeichnet die Konfiguration des Messfeldes durch Aufteilung in Unterbereiche mit jeweils fest zugeordneten SPADs.\\

    \subsection{Implementation}
        Um den TMF8821 softwareseitig zu implementieren wird die von SparkFun zur Verfügung gestellte Bibliothek verwendet. Diese beinhaltet alle notwendigen Methoden um den Sensor zu konfigurieren, Messungen durchzuführen und die Messergebnisse auszuwerten.\\

        Die Voreingestellte SPAD Map des Sensors besitzt eine Größe von 3x3 Messbereichen und die Messwinkel betragen in der Horizontalen 33° und in der Vertikalen 32°. Die ersten Messungen, mit dem in der Bibliothek zur Verfügung gestellten Codebeispiel Example-01\_Basic, welches alle Messewerte auf dem Seriellen Monitor ausgibt, lieferten sehr zufriedenstellende Ergebnisse. Dabei wurde eine Hand in unterschiedlich abgemessenen Abständen und an unterschiedlichen Positionen vor den Sensor gehalten und die Werte auf dem Seriellen Monitor mit Position und Entfernung der Hand abgeglichen.\\

        Für die geplante Einwurföffnung des Gerippten ist ein Messwinkel von  maximal 33° jedoch nicht ausreichend, weshalb die beschriebenen Probemessungen ebenfalls mit anderen SPAD Map Konfigurationen durchgeführt wurden. Dabei war zu beobachten, dass die Konfigurationen, mit einem 4x4 oder 3x6 Messbereich besonders im Randbereich viele unplausible Ergebnisse lieferten. Da die Fehlerursache für dieses Verhalten nicht in kurzer Zeit ausgemacht werden konnte, wurde sich aufgrund der wenigen zur Verfügung stehenden Zeit auf die Verwendung einer SPAD Map mit einem 3x3 Messbereich konzentriert. Die vorkonfigurierte SPAD Map mit der ID 6 bietet mit 52° in der Vertikalen den größten Messwinkel aller vorkonfigurierten SPAD Maps, weshalb diese letztendlich im Prototypen Verwendung fand. Das Schema dieser SPAD MAP wird in Abbildung \ref{fig:SPAD-Map_6} dargestellt.\\

        \begin{figure}[H]
            \begin{center}
                \includegraphics[height=4cm]{media/03_technical_implementation/SPAD-Map_6.png}
            \end{center}
            \caption{Schema der verwendeten SPAD Map\protect\footnote{Quelle: https://cdn.sparkfun.com/assets/learn\_tutorials/2/2/8/9/TMF882X\_DataSheet.pdf}}
            \label{fig:SPAD-Map_6}
        \end{figure}

        Da bei dieser SPAD Map Konfiguration der vertikale Messwinkel größer ist als der horizontale Messwinkel muss der Sensor für einen maximal großen Messbereich um 90° versetzt eingebaut werden, sodass die Messfelder 1, 4 und 7 die obere Messreihe bilden und die Messfelder 3, 6 und 9 die untere. Da jedoch auch der horizontale Messwinkel mit 41° einen großen Messbereich abdeckt, der nach der Rotation in der Vertikalen aufgespannt ist, wird die daraufhin obere Messebene mit den Feldern 1, 4 und 7 bei der Messung nicht ausgewertet, da dieser Messbereich zu großen Teilen oberhalb der Einwurföffnung gelegen ist. Die zwei geforderten Messebenen sind somit durch die Messbereiche 2, 5 und 8 für die obere Messebene sowie 3, 6 und 9 für die untere gegeben.\\

        Die Implementation der abstrahierten Interaktion mit dem Sensor ist in der Datei tmf8821.cpp realisiert, die entsprechende Schnittstelle dazu durch die Header Datei tmf8821.hpp gegeben. Durch die dort definierte Methode init wird der Sensor konfiguriert. Das bedeutet, die SPAD Map wird auf die vordefinierte SPAD Map mit der ID 6 festgelegt und der zeitliche Abstand zwischen zwei Messungen wird auf 50\,ms gesetzt. Dieser Wert hat sich aus Testläufen mit unterschiedlichen Werten ergeben. Das Ziel ist diesen Wert so gering zu halten wie möglich, damit ein eingeworfener Gegenstand auf jeden Fall detektiert wird und nicht genau zwischen zwei Messungen eingeworfen werden kann. Die durchgeführten Tests haben ergeben, dass Messungen mit einem zeitlichen Abstand von unter 50\,ms jedoch ungenauere Messwerte hervorbrachten. Die init Methode sollte typischerweise in der Setup Methode der main Klasse aufgerufen werden.\\

        Die Methode start lässt den Sensor eine einzelne Messung durchführen und interpretiert zugleich das Ergebnis. Dazu werden die vom Sensor zurückgelieferten Messwert zu einem Status ausgewertet, welcher in der aktuellen Instanz des Sensorobjekts gespeichert wird. Dabei kann das Messergebnis einem von drei möglichen Status zugeordnet werden. Die Status und ihre Bedeutungen werden in folgender Tabelle erläutert.\\

        \begin{table}[H]
            \centering
            \begin{tabularx}{\textwidth}{ |l|X| } 
                \hline
                NONE & In keiner der beiden auszuwertenden Messreihen wird ein Objekt detektiert.\\
                \hline
                INCOMING & In der oberen Messebene wurde ein Objekt detektiert. \\
                \hline
                DETECTED & Der vorherige Zustand ist INCOMING und in der unteren Messebene wird ein Objekt detektiert, während in der oberen Messebene keines mehr detektiert wird. Dieser Zustand kann nicht mehr durch weitere Messungen geändert werden, sondern wird beim Auslesen des Sensorzustandes zurückgesetzt.\\
                \hline
            \end{tabularx}
        \end{table}

        Um den Zustand des Sensors auszulesen, kann die Methode getState aufgerufen werden. Diese gibt immer den aktuell gespeicherten Zustand zurück. Ein Parameter vom Typ bool gibt an, ob der Zustand auf NONE zurückgesetzt werden soll, wenn der aktuelle Zustand DETECTED ist. Diese Option dient lediglich Debug Zwecken und im Produktivsystem sollte die Methode grundsätzlich nur mit dem bool-Wert true aufgerufen werden, da ein Aufruf der getState Methode mit einem Parameterwert von true die einzige Möglichkeit ist, den DETECTED Zustand zurückzusetzen.\\
        
        Während des Verlaufs der technischen Umsetzung wurde deutlich, dass die Bedienung des Einwurfsensors durch den Arduino nur dann in entsprechend schneller Taktung erfolgen kann, wenn der Arduino keine weiteren Aufgaben erfüllen muss. Somit musste für die Steuerung und Auswertung des Einwurfsensors ein eigenständiger Arduino, im folgenden Sensor-Arduino genannt, eingesetzt werden, welcher über zwei digitale Leitungen mit einem zweiten Arduino, im folgenden Haupt-Arduino genannt, kommuniziert, der die restlichen Funktionen des Gerippten steuert. Eine der Leitungen wird vom Sensor-Arduino auf HIGH gesetzt, sobald der Status DETECTED ausgelesen wird. Wenn der Haupt-Arduino diesen Status erkannt hat, setzt dieser die zweite Leitung für eine Iteration seiner main loop auf HIGH, um die Meldung zu bestätigen. Diese Bestätigung wird wiederum vom Sensor-Arduino gelesen, woraufhin dieser die erste Leitung wieder auf LOW setzt. Somit dient der Sensor-Arduino dem Einwurfsensor als Steuergerät, welches dem Haupt-Arduino lediglich mitteilt, wann ein Einwurf detektiert wurde.\\

        Während der letzten Praxistests, im Endzustand der Modellbauphase wurde deutlich, dass die Messgeschwindigkeit für die Einwurfdetektion noch nicht ausreichend ist, um Einwürfe zuverlässig zu detektieren. Ein großer Teil der Einwürfe wurde nicht erkannt. Jedoch wurden 'falsche Einwürfe', bei denen beispielsweise die Hand hineingesteckt und wieder herausgezogen wurde, zuverlässig als nicht vollständige Einwürfe erkannt. Da es für die Vorstellung des Prototypen von Vorteil war eine zuverlässige Einwurfdetektion zu präsentieren, statt des zuverlässigen Ausschließens von nicht vollständigen Einwürfen wurde, die Bedingung für das Setzen des Detektionssignals angepasst, sodass jedes Mal ein Detektionssignal gesetzt wird, sobald der Sensorstatus nicht mehr NONE entspricht, was der Funktionsweise einer einzelnen Lichtschranke entspricht. Durch weitere Analyse des Quellcodes im Anschluss an die Präsentationsveranstaltung fiel auf, dass in der Methode start, zu sehen in Listing \ref{lst:tmf8821_start}, alle Messwerte mindestens doppelt und maximal vierfach durchlaufen werden, wenn der Sensorstatus vor der Messung den Wert INCOMING aufweist, da jeder Aufruf von checkMiddleRow oder checkBottomRow jeweils einmal über alle Messwerte der letzten Messung iteriert.\\
        
        \begin{listing}
            \begin{minted}{cpp}
            
void TMF8821::start(void)
{
    sensor.startMeasuring(results);
    IntakeState curr = state;
    switch (curr) 
    {
        case NONE:
            if (checkMiddleRow())
            {
                state = INCOMING;
            }
            break;
        case INCOMING:
            if (checkBottomRow() && !checkMiddleRow())
            {
                state = DETECTED;
            }
            else if (!checkBottomRow() && !checkMiddleRow())
            {
                state = NONE;
            }
            break;
        default:
            break;
    }
}
            
            \end{minted}            
            \caption{start Methode aus tmf8821.cpp ohne Kommentare und Logging Ausgaben}            
            \label{lst:tmf8821_start}            
        \end{listing}

        Die Auswertung der Messwerte zum neuen Status kann jedoch auch mit einer einzelnen Iteration über die Messdaten realisiert werden, indem die Methoden checkMiddleRow und checkBottomRow zu einer Methode zusammengefasst werden, die einmal durch die Messwerte iteriert und dabei zurückgibt in welchen Messebenen etwas detektiert oder eben nichts detektiert wurde. Diese Verbesserung bietet somit eine Reduktion der Laufzeit, welche möglicherweise ausreichend ist, um die Einwurfdetektion in ihrem geplanten Zustand funktionsfähig zu implementieren.
        
\section{Detektion von Flaschen im Flaschenring}
    \subsection{Diskussion}
        Bei der Detektion von Flaschen im Flaschenring ist zu beachten, dass hierfür ein Sensor verwendet werden muss, der Glas in verschiedenen Farben einwandfrei detektiert. Es zeigt sich, dass sowohl die meisten optischen Sensoren, als auch Ultraschallsensoren dazu in der Lage sind. Bei optischen Sensoren ist jedoch zu bedenken, dass die maximale Detektionsreichweite bei der Detektion von Glas kleiner sein kann, als vom Hersteller angegeben, da die Reflektivität von Glas, je nach dessen Einfärbung, nicht sehr hoch ist. Somit ist ein Ultraschallsensor für die Detektion von Flaschen die zuverlässigere Wahl.\\

        Ein weiteres Kriterium, welches vom Sensor erfüllt werden sollte, ist eine geringe Komponentengröße, da er sonst nicht ohne großen Aufwand zwischen Flaschenring und Tonnenkörper montiert werden kann. Das Sensormaß entlang seiner Messachse ist hierbei besonders ausschlaggebend.\\

        Die kleinsten Ultraschallsensoren die während der Komponentenrecherche ermittelt wurden besitzen Bauhöhen von einem bis zu zwei Zentimetern, während der flachste Lidarsensor der ermittelt wurde ein Bauhöhe von 3\,mm besitzt. Dabei handelt es sich um Digital Distance Sensor von Pololu. Welcher, aufgrund ebendieser geringen Bauhöhe und trotz der Einschränkung, dass die Reichweite eventuell geringer ausfällt, als vom Hersteller angegeben, für dieses Projekt ausgewählt wurde. Dieser Sensor wird in verschiedenen Ausführungen angeboten, wobei diese sich in ihrer maximalen und minimalen Messdistanz unterscheiden. Da es sich um einen Sensor mit digitalem Ausgangssignal handelt und somit nur detektiert wird, ob ein Objekt vorhanden ist und nicht wie weit es entfernt ist, muss sichergestellt sein, dass die Reichweite gering genug ist um nicht die, dem Sensor gegenüberliegende, Wandung des Flaschenfachs zu detektieren, da der Sensor seitlich am Flaschenfach angebracht wird. Da die Flaschenfächer zum Zeitpunkt der Materialauswahl nicht vollständig konzipiert waren, wurde die Sensorvariante ,mit einer Reichweite zwischen 0,5\,cm und 5\,cm ausgewählt und damit der Durchmesser der Flaschenfächer auf mindestens 5\,cm festgelegt. Die Polou Teilenummer dieser Sensorvariante ist 4050.\\
        
        Wie bereits erwähnt, wird der Sensor seitlich an den Fächern des Flaschenrings montiert. Eine Montage an der Unterseite des Fachs wurde ausgeschlossen, da dies sehr fehleranfällig ist. Beispielsweise könnte sich Dreck am Boden des Fachs sammeln und den Sensor somit blockieren. Da der Sensor zwischen Flaschenring und Tonnenkörper montiert wird und der Flaschenring eine leichte Neigung nach außen aufweist, ist der Sensor von der Horizontalen Ebene nach unten abweichend ausgerichtet und somit gegen grobe Verschmutzungen, die von oben in das Fach gelangen geschützt.\\

    \subsection{Implementation}
        Die Datei pololu\_digi5.cpp implementiert die Headerdatei pololu\_digi5.hpp und ermöglicht die Abstratktion der Sensorfunktion in der Software. Eine Instanz dieses Sensors wird duch den Konstruktor initialisiert, welchem der entsprechende Arduino Anschlusspin übergeben wird. Da der Sensor ein hohes Potential an seinen Ausgangspin anlegt, solange nichts detektiert wird, wird der pinmode INPUT\_PULLUP verwendet, sodass das Signal am Eingangspin des Arduino ebenfalls hohes Potential besitzt, solange die angeschlossene Leitung das Signal nicht aktiv auf das niedrige Potenzial bringt.\\

        Die Methode read liest das Signal am entsprechenden Pin aus, negiert dieses und gibt das Ergebnis der Negation als bool Wert zurück. Die Negation wird durchgeführt, sodass ein Rückgabewert von true einer Detektion entspricht und ein Rückgabewert von false bedeutet, dass sich kein Objekt im Messbereich des Sensors befindet.

\section{Kommunikation zwischen Endgeräten} \label{sec:communications}

    \subsection{Diskussion}
        Um die Kommunikation zwischen mehreren Mikrocontrollern zu realisieren müssen wir vorallem die Faktoren der Reichweite, Kompatibilität, des Energieaufwands und der Art Kommunikation berücksichtigen. Die Datenrate ist in unserem Anwendungsfall zu vernachlässigen, da wir nur die Animationsevents übertragen müssen.

        \begin{table}[H]
            \caption{Vergleich verschiedener Kommunikationsprotokollen}
            \centering
            \begin{tabularx}{\textwidth}{  X | X | X | X }
                \textbf{Bluetooth} & \textbf{Bluetooth Low Energy} & \textbf{Wi‑Fi 4 802.11n} & \textbf{Wi-Fi HaLow/IEEE802.11ah} \\ [0.5ex] \hline\hline
                Mittlerer Energieverbrauch &
                Geringer Energieverbrauch &
                Hoher Energieverbrauch &
                Mittlere Energieverbrauch \\
                &&\\
                Geringe Reichweite (bis zu 30m) &
                Mittlere Reichweite (bis zu 100m) &
                Mittlere Reichweite (bis zu 90m) &
                Hohe Reichweite (bis zu 1km) \\
                &&\\
                In vielen Mikrocontrollern integriert &
                In vielen Mikrocontrollern integriert &
                In vielen Mikrocontrollern integriert &
                Kaum auf dem Markt vertreten - teuer \\
                &&\\
                Peer To Peer &
                Server - Client &
                Server - Client &
                Server - Client \\
                &&\\
            \end{tabularx}
            \label{tab:compare_mics}
        \end{table}

        Mit dieser Übersicht haben wir uns schlussendlich für Bluetooth Low Energy entschieden, was uns schlussendlich auch zum Arduino Nano 33 BLE geführt hat, einer der wenigen Arduinos mit BLE 5.0.

    \subsection{Implementation}

    BLE verwendet eine Server-Client-Kommunikation, wobei wir bei Servern von Peripherals reden und bei Clients von Centrals.
    Ein Peripheral kann mehrere Services anbieten, welche wiederum mehrere Characteristics besitzen. Metaphorisch kann ein Service als Pinnwand und die Characteristics als Notizzettel beschrieben werden, die von den Centrals gelesen und/oder beschrieben werden können. Zusätzlich können Centrals auch auf Änderungen einer Characteristic horchen.

    Mit der bereitgestellte BLE Bibliothek von Arduino konnten wir unseren Mesh Ansatz leider nicht verfolgen, jeden Mikrocontroller eine doppelte Rolle, Peripheral und Central gleichzeitig, zuzuweisen. Der in anderen Implementation realisierbare Ansatz wird auf den Nano 33 BLE leider nicht unterstützt. So haben wir uns für unser Modell auf eine klassische Server-Client-Kommunikation verständigt, wobei unser Hauptmodell in diesem Fall nur Events an unsere Rauten-Modelle sendet.


    \subsubsection{Sender (Peripheral)}

        Auf der Seite des Peripherals müssen wir das BLE-Modul selbst initialisieren und ein Service und ein Characteristic bereitstellen.
        Service und Characteristic benötigen dafür jeweils eine UUID, eine einzigartige Adresse, über die sie in unserem Fall auch von den Centrals gefunden werden. Diese sind als Konstanten im Code hinterlegt und werden durch das Makro ARDUINO\_ID je nach Environment verwendet.
        Dabei ist vorgegeben, dass der Peripheral die ARDUINO\_ID 1 besitzen muss, da diese verwendet wird, um nach jenem Peripheral zu suchen.
        Das Characteristic wird auf den von uns als Standardwert definierten Wert 0 gesetzt. Dieser Ablauf ist im Codebeispiel\,\ref{lst:ble_code_1} zu sehen.\\

        \begin{listing}
            \begin{minted}{cpp}
// Einschub aus neo_animation.hpp:
BLEService service;
BLEUnsignedCharCharacteristic characteristic;

boolean BLEPeripheralWrapper::init(void) 
{
    !BLE.begin()
    BLE.setAdvertisedService(service);
    BLE.setLocalName(BLE_NAME);
    service.addCharacteristic(characteristic);
    BLE.addService(service);
    characteristic.writeValue(0);
    BLE.advertise();
}
            \end{minted}
            \caption{Initialisierung des BLE-Peripherals, ohne Logs.
            }
            \label{lst:ble_code_1}
        \end{listing}

        Wurde nun ein Einwurf detektiert und soll ein Event in die Characteristic geschrieben werden, so wird dies nur für ein bestimmten Zeitraum getan, bevor der Standardwert 0 erneut gesetzt wird.
        Das ist nötig um keine erneute Animationen der Centrals zu verursachen, falls zwischenzeitlich ein Verbindungsabbruch vorliegt.
        Daher wird sich hier ein Zeitstempel berechnet, an dem der Reset vollzogen werden soll.
        Daraufhin wird der übergebene Wert publiziert.
        (Siehe Codebeispiel\,\ref{lst:ble_code_3})\\

        \begin{listing}
            \begin{minted}{cpp}
void BLEPeripheralWrapper::publishEvent(u_int8_t val)
{
    ts_end = millis() + BLE_ADVERTISING_DURATION_MS;
    characteristic.writeValue(val);
}
            \end{minted}
            \caption{Setzen eines Wertes der Characteristic des BLE-Peripherals, ohne Logs.
            }
            \label{lst:ble_code_3}
        \end{listing}

        Für das BLE-Modul benötigen wir, wie in Kapitel\,\ref{sec:platform} erwähnt, eine update()-Methode. Diese wird benötigt um Interaktionen der Centrals zu bearbeiten. In unserer Implementation\,\ref{lst:ble_code_2} wird hier zusätzlich der Timer überprüft und im Zweifelsfall der Standardwert zurückgesetzt.

        \begin{listing}
            \begin{minted}{cpp}
void BLEPeripheralWrapper::update()
{
    BLE.poll();
    if (millis() > ts_end) 
    {
        characteristic.writeValue(0);
        ts_end = -1ul;
    }
}
            \end{minted}
            \caption{Update des BLE-Peripherals, ohne Logs.
            }
            \label{lst:ble_code_2}
        \end{listing}


    \subsubsection{Empfänger (Central)}

        Auf der Seite der Empfänger, der Centrals, wird, solange dieser nicht gefunden wurde, nach dem Peripheral gescannt. Dafür wird die oben erwähnte UUID verwendet.

        \begin{minted}{cpp}
BLE.scanForUuid(UUIDS[PERIPHERAL_ARDUINO_ID].service);
        \end{minted}

        Ab dem Moment ab dem der Central fündig wurde, werden verschiedene Stufen des Kontakts aufgebaut, es wird der Service und daraufhin das Characteristic gesucht. Der darauf folgendene Teil ist im Codebeispiel\,\ref{lst:ble_code_4} gezeigt. Hier abonniert der Central die Characteristic um die Möglichkeit zu bekommen zu überprüfen, ob sich der gesetzte Wert verändert hat.
        Solange die Verbindung nicht abbricht und der Wert sich nicht ändert, wird weiterhin in der Schleife verblieben. Ab dem Moment an dem ein neuere Wert, der ungleich dem Standardwert ist, gelesen wird, wird eine Animation gestartet und angezeigt.

\begin{listing}
    \begin{minted}{cpp}
[...]
    if (characteristic 
                && characteristic.canSubscribe() 
                && characteristic.subscribe())
    {
        while (peripheral.connected())
        {
            if (characteristic.valueUpdated())
            {
                characteristic.readValue(val);
                if (val) leds.startAnimation(ANIMATION_BLUE_UP);
                while (leds.animationActive()) leds.update();
            }
        }
    }
[...]
    \end{minted}
    \caption{Subscribe-Funktionalität skizziert.}
    \label{lst:ble_code_4}
\end{listing}

\section{Füllstandsmessung}
    \subsection{Diskussion}
        Zum Messen des Füllstandes soll ein Sensor, oder eventuell auch mehrere, an der Unterseite des Tonnendeckels befestigt werden. Bei der Füllstandsmessung ist zu beachten, dass er Füllstand an unterschiedlichen Positionen in der Tonne eine unterschiedliche Höhe aufweisen kann. Somit existiert kein einzelner korrekter Füllstandswert, wie es bei einer Flüssigkeit der Fall wäre. Daraus ergeben sich verschiedene Möglichkeiten für die Ermittlung eines Füllstandswertes. Eine dieser Möglichkeiten wäre, mehrere Messungen an unterschiedlichen Punkten durchzuführen und daraus einen Mittelwert zu bilden oder den Punkt mit dem höchsten Füllstand als aktuellen Wert anzunehmen. Eine weitere Möglichkeit besteht darin lediglich eine Messung an einer fixen Position durchzuführen. Diese Methode besitzt zwar eine gewisse Fehleranfälligkeit, da der Füllstand an einem anderen Punkt höher sein könnte, liegt der Messpunkt jedoch mittig, sollte in den meisten Fällen dort auch der aktuell höchste Füllstand ermittelt werden, da sich die Oberfläche des Mülls in der Tonne häufig zu einem sehr flachen Kegel auftürmt. Der klare Vorteil der Umsetzung mit einem Sensor liegt jedoch in der Einfachheit der Umsetzung dieser Methode, da nur ein Sensor benötigt wird und nicht mehrere Sensordaten miteinander verrechnet werden müssen.\\
        
        Es besteht zusätzlich die Möglichkeit auch für Füllstandsmessung den, im Abschnitt Einwurferkennung beschriebenen, Sensor TMF8821 von SparkFun zu verwenden, da dieser jedoch vergleichsweise hohe Kosten aufweist und eine Komplexität bietet, die von der Füllstandsmessung nicht zwingend gefordert wird, soll ein simplerer Sensor eingesetzt werden. Hierfür kommen sowohl optische als auch Ultraschallsensoren in Frage, die eine Reichweite von mindestens 140\,cm besitzen, da dies in etwa der Gesamthöhe des Gerippten entspricht. Die Auswahl der Sensoren bei den von uns ausgewählten Zulieferern war im unteren Preissegment nicht besonders groß, weshalb wir uns für den Sharp GP2Y0A60SZLF Analog Distance Sensor auf einem Pololu Carrier entschieden. Dabei handelt es sich um einen optischen Sensor mit einer Reichweite von 10\,cm bis 150\,cm. Das Ausgangssignal des Sensors ist analog.\\

        Die Füllstandsmessung ist eine Funktion des Gerippten, die in diesem Projekt jedoch keine weitere Außenwirkung aufweisen soll, und wird lediglich implementiert um das Konzept eines smarten Mülleimers zu verdeutlichen. In einer weiteren Umsetzung können die Daten zum Füllstand dann beispielsweise an eine zentrale Steuereinheit übertragen werden. Weitere Informationen zur möglichen Weiterführung des Projekts befinden sich im Kapitel Zukünftige Entwicklungsmöglichkeiten.\\

    \subsection{Implementation} 
        Die Interaktion mit dem Sensor wird im Quellcode in der Datei level\_meter.cpp implementiert. Diese implementiert wiederum die Headerdatei level\_meter.hpp. Um eine Instanz des Sensors zu initialisieren muss dem Konstruktor zum einen der Anschlusspin des Arduinos übergeben werden und weiterhin die Abstandsmaße vom Sensor bis zum leeren Füllstand, sowie bis zum vollen Füllstand. Dabei ist zu beachten, dass der Abstandswert zwischen Sensor und vollem Füllstand mindestens 10\,cm betragen sollte, da dies die minimale Messdistanz des Sensors ist.

        Des weiteren existiert die Methode calculateDistance, welche den vom Sensor ausgegebenen Wert am Arduino Pin einliest und daraus die Distanz zum detektierten Objekt errechnet. Für die Implementation dieser Methode musste jedoch zuerst ermittelt werden, wie ein Signalwert in einen Distanzwert umgerechnet wird. Dazu wurde der Sensor auf einem Breadboard befestigt und mit dem Arduino verbunden. Der Sensor wurde auf einer ebenen Fläche so ausgerichtet, dass seine Messebene parallel zum Untergrund verläuft. Danach wurde vor dem Sensor eine weißer Karton im Abstand von 10\,cm platziert. Der Arduino wurde so konfiguriert, dass der Sensorwert alle 25\,ms 500 mal nacheinander ausgelesen wird. Dabei wird der Mittelwert der 500 Messungen berechnet und vom Arduino auf dem seriellen Monitor ausgegeben. Dieses Vorgehen wurde mit, in 5\,cm Schritten, steigenden Abständen zum Karton wiederholt, bis zu einem maximalen Abstand von 150\, cm. Die gemessenen Durchschnittswerte wurden im Programm Excel von Microsoft eingepflegt. Dort wurde aus den Daten ein Diagramm, inklusive Trendlinie und Trendlinienformel erstellt. Die Ergebnisse sind in Tabelle \ref{tab:calibration} und Abbildung \ref{fig:calibration} zu sehen.

        \begin{table}
            \centering
            \caption{Ergebnisse der Abstandsmessungen}
            \begin{tabular}{ c c || c c } 
                \textbf{Distanz (cm)} & \textbf{Messwert} & \textbf{Distanz (cm)} & \textbf{Messwert}\\ [0.5ex]
                \hline
                \hline
                10 & 574 & 85 & 238\\
                15 & 423 & 90 & 235\\
                20 & 343 & 95 & 231\\
                25 & 310 & 100 & 226\\
                30 & 303 & 105 & 223\\
                35 & 300 & 110 & 219\\
                40 & 294 & 115 & 216\\
                45 & 287 & 120 & 214\\
                50 & 279 & 125 & 211\\
                55 & 273 & 130 & 209\\
                60 & 265 & 135 & 207\\
                65 & 259 & 140 & 204\\
                70 & 253 & 145 & 203\\
                75 & 249 & 150 & 202\\
            \end{tabular}            
            \label{tab:calibration}
        \end{table}

        \begin{figure}[H]
            \begin{center}
                \includegraphics[width=12cm]{media/03_technical_implementation/calibration.png}                
            \end{center}
            \caption{Von Microsoft Excel generierter Graph auf Basis der Messdaten}
            \label{fig:calibration}
        \end{figure}

        Es zeigt sich, dass die Trendlinie, insbesondere bei den kurzen Distanzen, den Messpunkten sehr gut folgt. Bei den mittleren Distanzen gibt es leichte Abweichungen, da dort auch die Messpunkte keinem klar erkennbaren Muster folgen. Das führt dazu, dass die Messungen, insbesondere in diesem Bereich, kein sehr genaues Ergebnis liefern werden. Jedoch werden die Abweichungen vom Ist-Zustand auch nicht so groß sein, dass die Messwerte für eine Auswertung, durch beispielsweise die FES, unbrauchbar sind. Der größte Nutzen der Füllstandsmessung, das Detektieren einer vollen Tonne, ist einwandfrei gegeben, durch die Genauigkeit der Trendlinie bei kurzen Distanzen.\\

        Die für den Füllstandssensor implementierte Methode getFillLevel ruft die bereits angesprochene Methode liest den Messwert des Sensors aus und lässt anhand der bereits angesprochenen Methode calculateDistance die gemessene Distanz berechnen. Aus der gemessenen Distanz, der Distanz für den vollen Zustand und der Distanz für den leeren Zustand wird dann der Füllgrad berechnet und als abgerundeter, ganzzahliger Teil von 100 zurückgegeben.

\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

\section{Stückliste}
    \begin{table}[H]
        \centering
        \begin{tabularx}{\textwidth}{ | l | X | }\hline
            \textbf{Menge} & \textbf{Bezeichnung} \\\hline
            4              & Arduino Nano 33 BLE \\\hline
            1              & Sparkfun Qwiic dToF Imager - TMF8821 \\\hline
            3              & Pololu 5cm Digital Distance Sensor \\\hline
            1              & Sharp GP2Y0A60SZLF Analog Distance Sensor 10-150cm \\\hline
            30             & Adafruit Neopixel RGBW 0.2W \\\hline            1              & Adafruit NeoPixel RGB LED Strip 30 LEDs/m 5m \\\hline
            2              & Level Shifter, Joy-IT TXB0104 \\\hline
            1              & Netzteil POS-50-5-C 5V 10A \\\hline
            5              & Solderable Breadboards \\\hline
            40 Meter       & 0.75mm\textsuperscript{2} Kupferkabel - verschiedene Farben \\\hline
            1 Meter        & 1.5mm\textsuperscript{2} Kupferkabel - verschiedene Farben \\\hline
            ca. 170        & Crimps \\\hline
            ca. 50         & Stecker \\\hline
        \end{tabularx}
    \end{table}

\section{Schaltpläne}
    In den folgenden Grafiken wird die Verschaltung der Arduino Mikrocontroller mit den Sensoren und Leuchtmitteln dargestellt. Dabei ist in Abbildung \ref{fig:circuit_diagram_transmitter} die Verschaltung der Komponenten der großen Gesamtmodells zu sehen, während Abbildung \ref{fig:circuit_diagram_receiver} den Schaltplan des kleinen Rautenmodells zur Präsentation der Bluetoothkommunikation zeigt.

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\textwidth]{media/03_technical_implementation/circuit_diagram_transmitter.png}
        \end{center}
        \caption{Schaltplan des Hauptmodells}
        \label{fig:circuit_diagram_transmitter}
    \end{figure}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=6.8cm]{media/03_technical_implementation/circuit_diagram_receiver.png}
        \end{center}
        \caption{Schaltplan der zwei Rauten Modelle}
        \label{fig:circuit_diagram_receiver}
    \end{figure}

\section{Zusammenführung von Modell und Technik}

    \subsubsection{Der Maschinenraum}
        
        Für die zwei Arduinos, das Netzteil und die Breadboards für die Steckverbindungen unserer Sensoren und LEDs brauchen wir im Mülleimer einen geschützten Ort. Wir haben uns dafür entschieden, diesen \enquote{Maschinenraum} im Boden der Tonne zu platzieren, und einen um 10 Zentimeter erhöhten Doppelte-Boden einzubauen, auf dem dann die innere Mülltonne steht.
        So kann man die innere und danach die äußere Tonne nach oben rausheben, da beide Böden nicht fest mit der Tonne veranker sind.
        Damit kommen wir immer an unsere Technik.
        Dann habe wir am unteren Rand der Tonne noch ein Loch für unsere Stromverkabelung geschnitten, sodass das das einzige Kabel ist, was von außen sieht.

    \subsubsection{Verkabelung}

        Die restlichen Kabel sind an der Innenwand der äußeren Tonne nach oben gezogen und dann dort durch kleine Löcher nach Bedarf nach außen geführt.


    \subsubsection{Technik im Flaschenring}

        Die LEDs der Fächer im Flaschenring haben wir von unten außen an die Konstruktion geklebt und vorher passende Löcher in die Fächer geschnitten. Analog dazu sind wir bei den 5cm Lidar Sensoren an der Rückseite der Fächer vorgegangen. (Zwischen Tonnenwand und Flaschenring.)

    \subsubsection{LED-Strips}

        Da die Rauten unterschiedliche Kantenlängen zwischen 8 und 10,5cm besitzen, die LED-Strips aber parallel zum Modellbau gelötet werden mussten, brauchten wir einen Ansatz der einen gewissen Spielraum ermöglicht. Ebenfalls unbekannt war, inwiefern die Rautenstruktur aus Schaumstoff anpassbar waren, da wir zu dem Zeitpunkt darüber noch keine Informationen bekommen hatten.
        Wir haben daher zwischen den geteilten LED-Strips längere Kabelverbindungen als nötig verwendet, denn während wir unter perfekten Umständen die Abstände der Übergange zwischen zwei Rauten hätten ausmessen können und wir die Kabel damit unter oder an den Rauten hätten verlegen können, müssen wir so die Länge der Kabel an jedem Übergang zweier Strips variieren können.
        Umgesetzt wurde das, in dem wir an jeder dieser Übergänge ein etwa 8mm dickes Loch in die Tonne gebohrt haben, um das übrige Kabel als Schlaufe in die Tonne zu führen. Die benötigte Drehung des LED-Strips um die Lötpunkte und Kabel in die Richtung des Lochs zu drehen, haben wir vorsichtig am LED-Strip selbst gebogen.
        Die langen Strecken, an denen das Kabel auf eine andere Höhe gebracht  werden mussten (zu sehen in Abbildung\,\ref{fig:led_wiring_rhombus}) hatten wir ursprünglich geplant außen an der Raute langzuführen und an beiden Enden der Kante jeweils eine Schlaufe in die Tonne führen zu lassen, sodass wir die LED-Strips einfacher hätten abmontieren können.
        Unter der Voraussetzung, dass wir die Strips an dem Schaumstoff der Rauten festgeklebt wurde, haben wir uns aus ästhetischen Gründen dazu entschieden die Kabel an den langen Kanten in der Tonne langzuführen.

